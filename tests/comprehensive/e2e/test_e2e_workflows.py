#!/usr/bin/env python3
"""
Á´ØÂà∞Á´ØÂ∑•‰ΩúÊµÅÊµãËØïÂ•ó‰ª∂
ÁõÆÊ†áÔºöÊ®°ÊãüÁúüÂÆûÁî®Êà∑Âú∫ÊôØÔºåÈ™åËØÅÁ≥ªÁªüÂÆåÊï¥ÂäüËÉΩÊµÅÁ®ã
"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
import pytest


import asyncio
import json
from unittest.mock import Mock, AsyncMock, patch, MagicMock, call
from datetime import datetime, timedelta
from pathlib import Path
import uuid

# Mock Â§ñÈÉ®‰æùËµñ
sys.modules['pydantic'] = MagicMock()
sys.modules['pydantic_settings'] = MagicMock()
sys.modules['aiofiles'] = MagicMock()
sys.modules['watchdog'] = MagicMock()
sys.modules['watchdog.observers'] = MagicMock()
sys.modules['watchdog.events'] = MagicMock()
sys.modules['redis'] = MagicMock()
sys.modules['redis.asyncio'] = MagicMock()
sys.modules['fastapi'] = MagicMock()
sys.modules['sentence_transformers'] = MagicMock()
sys.modules['openai'] = MagicMock()


# ===== Â∑•‰ΩúÊµÅ 1: Áî®Êà∑ËøûÊé•ÂíåÂëΩ‰ª§ÊâßË°å =====
@pytest.mark.asyncio
async def test_user_connection_command_workflow():
    """ÊµãËØïÁî®Êà∑ËøûÊé•„ÄÅÂèëÈÄÅÂëΩ‰ª§„ÄÅÊé•Êî∂ËæìÂá∫ÁöÑÂÆåÊï¥ÊµÅÁ®ã"""
    print("\nüìã Âú∫ÊôØ: Áî®Êà∑ÈÄöËøáWebSocketËøûÊé•Âπ∂ÊâßË°åÂëΩ‰ª§")
    
    # ÂàõÂª∫Á≥ªÁªüÁªÑ‰ª∂
    from backend.services.event_bus import EventBus, Event
    from backend.services.terminal_bridge import TerminalBridge, TerminalState
    from backend.core.command_manager import CommandManager
    from backend.models.base import EventType, CommandStatus
    
    with patch('backend.core.command_manager.TerminalBridge') as MockTerminalBridge:
        # ÂàùÂßãÂåñ‰∫ã‰ª∂ÊÄªÁ∫ø
        event_bus = EventBus()
        await event_bus.start()
        
        # Ê®°ÊãüÁªàÁ´ØÊ°•Êé•
        mock_terminal = Mock(spec=TerminalBridge)
        mock_terminal.send_command = AsyncMock()
        mock_terminal.is_alive.return_value = True
        mock_terminal.is_running = True
        
        # ÂàõÂª∫Ê®°ÊãüÁä∂ÊÄÅ
        mock_state = Mock(spec=TerminalState)
        mock_state.is_ready = True
        mock_state.is_alive = True
        mock_terminal.state = mock_state
        
        # ÂàõÂª∫ÂëΩ‰ª§ÁÆ°ÁêÜÂô®
        command_manager = CommandManager(mock_terminal)
        command_manager.event_bus = event_bus
        
        # Êî∂ÈõÜ‰∫ã‰ª∂
        events_received = []
        
        async def event_collector(event):
            events_received.append({
                'type': event.type,
                'data': event.data,
                'timestamp': datetime.now()
            })
        
        # ËÆ¢ÈòÖÂÖ≥ÈîÆ‰∫ã‰ª∂
        event_bus.subscribe(EventType.COMMAND_EXECUTED, event_collector)
        event_bus.subscribe(EventType.TERMINAL_OUTPUT, event_collector)
        
        # Ê≠•È™§1: Áî®Êà∑ÂèëÈÄÅÂëΩ‰ª§
        user_command = "echo Hello, Claude Code!"
        print(f"   1Ô∏è‚É£ Áî®Êà∑ÂèëÈÄÅÂëΩ‰ª§: {user_command}")
        
        # ÊâßË°åÂëΩ‰ª§
        result = await command_manager.execute_command(user_command)
        
        # Ê≠•È™§2: È™åËØÅÂëΩ‰ª§Ë¢´ÂèëÈÄÅÂà∞ÁªàÁ´Ø
        mock_terminal.send_command.assert_called_once_with(user_command)
        print(f"   2Ô∏è‚É£ ÂëΩ‰ª§Â∑≤ÂèëÈÄÅÂà∞ÁªàÁ´Ø")
        
        # Ê≠•È™§3: Ê®°ÊãüÁªàÁ´ØËæìÂá∫
        terminal_output = "Hello, Claude Code!"
        await event_bus.publish(Event(
            type=EventType.TERMINAL_OUTPUT,
            source="terminal_bridge",
            data=terminal_output
        ))
        
        # Á≠âÂæÖ‰∫ã‰ª∂Â§ÑÁêÜ
        await asyncio.sleep(0.1)
        
        # Ê≠•È™§4: È™åËØÅ‰∫ã‰ª∂ÊµÅ
        assert len(events_received) >= 1
        command_events = [e for e in events_received if e['type'] == EventType.COMMAND_EXECUTED]
        assert len(command_events) >= 1
        print(f"   3Ô∏è‚É£ Êî∂Âà∞ {len(events_received)} ‰∏™‰∫ã‰ª∂")
        
        # Ê≠•È™§5: È™åËØÅÁªìÊûú
        assert result is not None
        print(f"   4Ô∏è‚É£ ÂëΩ‰ª§ÊâßË°åÊàêÂäü")
        
        await event_bus.stop()
        print("   ‚úÖ Áî®Êà∑ÂëΩ‰ª§ÊâßË°åÂ∑•‰ΩúÊµÅÂÆåÊàê")


# ===== Â∑•‰ΩúÊµÅ 2: ‰∏ä‰∏ãÊñáÁõëÊéßÂíåÊô∫ËÉΩÂª∫ËÆÆ =====
@pytest.mark.asyncio
async def test_context_monitoring_suggestion_workflow():
    """ÊµãËØï‰∏ä‰∏ãÊñáÁõëÊéß„ÄÅÂàÜÊûêÂíåÊô∫ËÉΩÂª∫ËÆÆÁîüÊàêÁöÑÂÆåÊï¥ÊµÅÁ®ã"""
    print("\nüìã Âú∫ÊôØ: ‰∏ä‰∏ãÊñá‰ΩøÁî®ÁéáËøáÈ´òÊó∂ÁîüÊàêÂéãÁº©Âª∫ËÆÆ")
    
    from backend.services.event_bus import EventBus, Event
    from backend.services.context_monitor import ContextMonitor, ContextState, FileInfo
    from backend.core.suggestion_engine import SuggestionEngine
    from backend.services.memory_manager import MemoryManager
    from backend.models.base import EventType, SuggestionPriority
    
    # ÂàùÂßãÂåñÁªÑ‰ª∂
    event_bus = EventBus()
    await event_bus.start()
    
    # ÂàõÂª∫ÂÜÖÂ≠òÁÆ°ÁêÜÂô®ÔºàmockÔºâ
    memory_manager = Mock(spec=MemoryManager)
    
    # ÂàõÂª∫Âª∫ËÆÆÂºïÊìé
    suggestion_engine = SuggestionEngine()
    suggestion_engine.event_bus = event_bus
    await suggestion_engine.initialize(memory_manager)
    
    # Êî∂ÈõÜÁîüÊàêÁöÑÂª∫ËÆÆ
    suggestions_received = []
    
    async def suggestion_collector(event):
        if event.type == EventType.SUGGESTION_GENERATED:
            suggestions_received.append(event.data)
    
    event_bus.subscribe(EventType.SUGGESTION_GENERATED, suggestion_collector)
    
    # Ê≠•È™§1: ÂàõÂª∫È´ò‰∏ä‰∏ãÊñá‰ΩøÁî®ÁéáÁä∂ÊÄÅ
    print("   1Ô∏è‚É£ Ê®°ÊãüÈ´ò‰∏ä‰∏ãÊñá‰ΩøÁî®Áéá (90%)")
    high_usage_state = Mock(spec=ContextState)
    high_usage_state.percentage = 90.0
    high_usage_state.token_count = 180000
    high_usage_state.token_limit = 200000
    high_usage_state.files_loaded = [
        Mock(spec=FileInfo, path="main.py", size=50000),
        Mock(spec=FileInfo, path="utils.py", size=30000),
        Mock(spec=FileInfo, path="models.py", size=40000)
    ]
    high_usage_state.session_start = datetime.now() - timedelta(hours=2)
    
    # Ê≠•È™§2: Ëß¶ÂèëÂàÜÊûê
    print("   2Ô∏è‚É£ Ëß¶ÂèëÂª∫ËÆÆÂºïÊìéÂàÜÊûê")
    suggestions = await suggestion_engine.analyze(high_usage_state)
    
    # Á≠âÂæÖ‰∫ã‰ª∂Â§ÑÁêÜ
    await asyncio.sleep(0.1)
    
    # Ê≠•È™§3: È™åËØÅÂª∫ËÆÆÁîüÊàê
    assert len(suggestions) > 0
    compact_suggestions = [s for s in suggestions if s.type == "compact"]
    assert len(compact_suggestions) > 0
    
    compact_suggestion = compact_suggestions[0]
    assert compact_suggestion.priority == SuggestionPriority.HIGH
    assert compact_suggestion.confidence > 0.9
    print(f"   3Ô∏è‚É£ ÁîüÊàê‰∫Ü {len(suggestions)} ‰∏™Âª∫ËÆÆ")
    print(f"      - ÂéãÁº©Âª∫ËÆÆ: {compact_suggestion.reason}")
    
    # Ê≠•È™§4: È™åËØÅÂª∫ËÆÆ‰∫ã‰ª∂
    assert len(suggestions_received) == len(suggestions)
    print(f"   4Ô∏è‚É£ ÂèëÂ∏É‰∫Ü {len(suggestions_received)} ‰∏™Âª∫ËÆÆ‰∫ã‰ª∂")
    
    # Ê≠•È™§5: Ê®°ÊãüÁî®Êà∑Êé•ÂèóÂª∫ËÆÆ
    await suggestion_engine.record_feedback(compact_suggestion.id, accepted=True)
    print("   5Ô∏è‚É£ Áî®Êà∑Êé•Âèó‰∫ÜÂéãÁº©Âª∫ËÆÆ")
    
    await event_bus.stop()
    print("   ‚úÖ ‰∏ä‰∏ãÊñáÁõëÊéßÂíåÂª∫ËÆÆÂ∑•‰ΩúÊµÅÂÆåÊàê")


# ===== Â∑•‰ΩúÊµÅ 3: ÂÜÖÂ≠òÁ≥ªÁªüÂÆåÊï¥ÊµÅÁ®ã =====
@pytest.mark.asyncio
async def test_memory_system_workflow():
    """ÊµãËØï‰ªéÂØπËØùÂÜÖÂÆπÂà∞ÂÜÖÂ≠òÂ≠òÂÇ®ÂíåÊ£ÄÁ¥¢ÁöÑÂÆåÊï¥ÊµÅÁ®ã"""
    print("\nüìã Âú∫ÊôØ: ‰øùÂ≠òÈáçË¶ÅÂØπËØùÂÜÖÂÆπÂà∞ÂÜÖÂ≠òÁ≥ªÁªü")
    
    from backend.services.event_bus import EventBus, Event
    from backend.services.memory_manager import MemoryManager, MemoryFile
    from backend.services.cache_manager import CacheManager
    from backend.models.base import EventType, MemoryLevel
    
    with patch('backend.services.cache_manager.settings') as mock_settings:
        mock_settings.has_redis = False
        mock_settings.claude_home = Path("/test/home")
        
        # ÂàùÂßãÂåñÁªÑ‰ª∂
        event_bus = EventBus()
        await event_bus.start()
        
        cache_manager = CacheManager()
        await cache_manager.initialize()
        
        memory_manager = MemoryManager()
        memory_manager.cache_manager = cache_manager
        memory_manager.event_bus = event_bus
        
        # Êî∂ÈõÜÂÜÖÂ≠ò‰∫ã‰ª∂
        memory_events = []
        
        async def memory_event_collector(event):
            memory_events.append(event)
        
        event_bus.subscribe(EventType.MEMORY_UPDATED, memory_event_collector)
        event_bus.subscribe(EventType.MEMORY_IMPORTED, memory_event_collector)
        
        # Ê≠•È™§1: ÂàõÂª∫ÈáçË¶ÅÂÜÖÂÆπ
        print("   1Ô∏è‚É£ ËØÜÂà´ÈáçË¶ÅÂØπËØùÂÜÖÂÆπ")
        important_content = """
# Python ÊÄßËÉΩ‰ºòÂåñÂÜ≥Á≠ñ

ÁªèËøáÂàÜÊûêÔºåÊàë‰ª¨ÂÜ≥ÂÆöÈááÁî®‰ª•‰∏ãÁ≠ñÁï•Ôºö
1. ‰ΩøÁî® asyncio ËøõË°åÂºÇÊ≠•ÁºñÁ®ã
2. ÂÆûÊñΩÁºìÂ≠òÁ≠ñÁï•ÂáèÂ∞ëÈáçÂ§çËÆ°ÁÆó
3. ‰ΩøÁî® profiling Â∑•ÂÖ∑ÂÆö‰ΩçÁì∂È¢à

Ëøô‰∏™ÂÜ≥Á≠ñÂ∞ÜÊòæËëóÊèêÂçáÁ≥ªÁªüÊÄßËÉΩ„ÄÇ
"""
        
        # Ê≠•È™§2: ÂàõÂª∫ÂÜÖÂ≠òÊñá‰ª∂
        print("   2Ô∏è‚É£ ÂàõÂª∫ÂÜÖÂ≠òÊñá‰ª∂")
        memory_file = MemoryFile(
            id=f"mem_{uuid.uuid4().hex[:8]}",
            path=Path("/test/project/decisions.md"),
            level=MemoryLevel.PROJECT,
            content=important_content,
            imports=[],
            size_bytes=len(important_content.encode()),
            metadata={
                "source": "conversation",
                "importance": "high",
                "tags": ["performance", "python", "decision"]
            }
        )
        
        # Ê≠•È™§3: ‰øùÂ≠òÂà∞ÂÜÖÂ≠òÁ≥ªÁªü
        print("   3Ô∏è‚É£ ‰øùÂ≠òÂà∞ÂÜÖÂ≠òÁ≥ªÁªü")
        # Ê®°Êãü‰øùÂ≠òÊìç‰Ωú
        memory_manager.memories[memory_file.id] = memory_file
        
        # ÂèëÂ∏ÉÂÜÖÂ≠òÊõ¥Êñ∞‰∫ã‰ª∂
        await event_bus.publish(Event(
            type=EventType.MEMORY_UPDATED,
            source="memory_manager",
            data={
                "memory_id": memory_file.id,
                "action": "created",
                "level": memory_file.level.value
            }
        ))
        
        # Á≠âÂæÖ‰∫ã‰ª∂Â§ÑÁêÜ
        await asyncio.sleep(0.1)
        
        # Ê≠•È™§4: È™åËØÅÂÜÖÂ≠ò‰øùÂ≠ò
        assert memory_file.id in memory_manager.memories
        assert len(memory_events) > 0
        print(f"   4Ô∏è‚É£ ÂÜÖÂ≠ò‰øùÂ≠òÊàêÂäüÔºåID: {memory_file.id}")
        
        # Ê≠•È™§5: ÊµãËØïÂÜÖÂ≠òÊêúÁ¥¢
        print("   5Ô∏è‚É£ ÊêúÁ¥¢Áõ∏ÂÖ≥ÂÜÖÂ≠ò")
        # Ê®°ÊãüÊêúÁ¥¢
        search_query = "python performance optimization"
        search_results = []
        
        for mem_id, mem_file in memory_manager.memories.items():
            if any(keyword in mem_file.content.lower() 
                   for keyword in search_query.lower().split()):
                search_results.append(mem_file)
        
        assert len(search_results) > 0
        assert memory_file in search_results
        print(f"   6Ô∏è‚É£ ÊâæÂà∞ {len(search_results)} ‰∏™Áõ∏ÂÖ≥ÂÜÖÂ≠ò")
        
        await event_bus.stop()
        print("   ‚úÖ ÂÜÖÂ≠òÁ≥ªÁªüÂ∑•‰ΩúÊµÅÂÆåÊàê")


# ===== Â∑•‰ΩúÊµÅ 4: ÈîôËØØÊÅ¢Â§çÂíåÈáçËØïÊú∫Âà∂ =====
@pytest.mark.asyncio
async def test_error_recovery_workflow():
    """ÊµãËØïÁ≥ªÁªüÈîôËØØÊÅ¢Â§çÂíåÈáçËØïÊú∫Âà∂"""
    print("\nüìã Âú∫ÊôØ: ÁªàÁ´ØËøûÊé•Â§±Ë¥•ÂêéÁöÑËá™Âä®ÈáçËØï")
    
    from backend.services.event_bus import EventBus, Event
    from backend.services.terminal_bridge import TerminalBridge
    from backend.models.base import EventType
    
    # ÂàùÂßãÂåñ‰∫ã‰ª∂ÊÄªÁ∫ø
    event_bus = EventBus()
    await event_bus.start()
    
    # Ë∑üË∏™ÈáçËØïÊ¨°Êï∞
    retry_attempts = []
    
    # ÂàõÂª∫‰ºöÂ§±Ë¥•ÁÑ∂ÂêéÊàêÂäüÁöÑÁªàÁ´ØÊ®°Êãü
    attempt_count = 0
    
    async def mock_start(workspace=None):
        nonlocal attempt_count
        attempt_count += 1
        retry_attempts.append({
            'attempt': attempt_count,
            'timestamp': datetime.now()
        })
        
        if attempt_count < 3:
            print(f"   ‚ùå Á¨¨ {attempt_count} Ê¨°ËøûÊé•Â§±Ë¥•")
            raise Exception("Connection failed")
        else:
            print(f"   ‚úÖ Á¨¨ {attempt_count} Ê¨°ËøûÊé•ÊàêÂäü")
            return True
    
    with patch('backend.services.terminal_bridge.TerminalBridge') as MockTerminalBridge:
        mock_terminal = Mock(spec=TerminalBridge)
        mock_terminal.start = mock_start
        mock_terminal.state.restart_count = 0
        mock_terminal.max_restart_attempts = 3
        MockTerminalBridge.return_value = mock_terminal
        
        # Ê≠•È™§1: È¶ñÊ¨°ËøûÊé•Â∞ùËØï
        print("   1Ô∏è‚É£ ÂºÄÂßãÁªàÁ´ØËøûÊé•")
        
        # Ê®°ÊãüÈáçËØïÈÄªËæë
        success = False
        for i in range(3):
            try:
                await mock_terminal.start()
                success = True
                break
            except Exception as e:
                if i < 2:  # ËøòÊúâÈáçËØïÊú∫‰ºö
                    await asyncio.sleep(0.1)  # Ê®°ÊãüÈáçËØïÂª∂Ëøü
                    continue
                else:
                    raise
        
        # Ê≠•È™§2: È™åËØÅÈáçËØï
        assert success == True
        assert len(retry_attempts) == 3
        print(f"   2Ô∏è‚É£ ÁªèËøá {len(retry_attempts)} Ê¨°Â∞ùËØïÂêéÊàêÂäüËøûÊé•")
        
        # Ê≠•È™§3: ÂèëÂ∏ÉÊÅ¢Â§ç‰∫ã‰ª∂
        await event_bus.publish(Event(
            type=EventType.TERMINAL_CONNECTED,
            source="terminal_bridge", 
            data={
                "status": "recovered",
                "attempts": len(retry_attempts)
            }
        ))
        
        print("   3Ô∏è‚É£ Á≥ªÁªüÂ∑≤ÊÅ¢Â§çÊ≠£Â∏∏")
        
        await event_bus.stop()
        print("   ‚úÖ ÈîôËØØÊÅ¢Â§çÂ∑•‰ΩúÊµÅÂÆåÊàê")


# ===== Â∑•‰ΩúÊµÅ 5: Âπ∂ÂèëÁî®Êà∑Êìç‰Ωú =====
@pytest.mark.asyncio
async def test_concurrent_users_workflow():
    """ÊµãËØïÂ§öÁî®Êà∑Âπ∂ÂèëÊìç‰ΩúÂú∫ÊôØ"""
    print("\nüìã Âú∫ÊôØ: Â§öÁî®Êà∑ÂêåÊó∂ÊâßË°åÂëΩ‰ª§ÂíåÊü•ËØ¢")
    
    from backend.services.event_bus import EventBus, Event
    from backend.core.command_manager import CommandManager
    from backend.services.cache_manager import CacheManager
    from backend.models.base import EventType
    
    with patch('backend.services.cache_manager.settings') as mock_settings:
        mock_settings.has_redis = False
        
        # ÂàùÂßãÂåñÂÖ±‰∫´ÁªÑ‰ª∂
        event_bus = EventBus()
        await event_bus.start()
        
        cache_manager = CacheManager()
        await cache_manager.initialize()
        
        # Ê®°ÊãüÁî®Êà∑Êìç‰Ωú
        async def user_operation(user_id: str, commands: list):
            """Ê®°ÊãüÂçï‰∏™Áî®Êà∑ÁöÑÊìç‰ΩúÂ∫èÂàó"""
            user_results = []
            
            for cmd in commands:
                # ÁºìÂ≠òÁî®Êà∑Áä∂ÊÄÅ
                await cache_manager.set(f"user_{user_id}_last_cmd", cmd)
                
                # ÂèëÂ∏ÉÂëΩ‰ª§‰∫ã‰ª∂
                await event_bus.publish(Event(
                    type=EventType.COMMAND_EXECUTED,
                    source=f"user_{user_id}",
                    data={"command": cmd, "user": user_id}
                ))
                
                user_results.append({
                    'user': user_id,
                    'command': cmd,
                    'timestamp': datetime.now()
                })
                
                # Ê®°ÊãüÂ§ÑÁêÜÂª∂Ëøü
                await asyncio.sleep(0.01)
            
            return user_results
        
        # Ê≠•È™§1: ÂàõÂª∫Â§ö‰∏™Áî®Êà∑ÁöÑÊìç‰Ωú
        print("   1Ô∏è‚É£ ÂàõÂª∫ 5 ‰∏™Âπ∂ÂèëÁî®Êà∑")
        user_tasks = []
        for i in range(5):
            user_commands = [
                f"echo User {i} command 1",
                f"ls -la /user{i}",
                f"python script{i}.py"
            ]
            task = user_operation(f"user_{i}", user_commands)
            user_tasks.append(task)
        
        # Ê≠•È™§2: Âπ∂ÂèëÊâßË°å
        print("   2Ô∏è‚É£ Âπ∂ÂèëÊâßË°åÁî®Êà∑Êìç‰Ωú")
        start_time = datetime.now()
        all_results = await asyncio.gather(*user_tasks)
        end_time = datetime.now()
        duration = (end_time - start_time).total_seconds()
        
        # Ê≠•È™§3: È™åËØÅÁªìÊûú
        total_operations = sum(len(results) for results in all_results)
        assert total_operations == 15  # 5 users √ó 3 commands
        print(f"   3Ô∏è‚É£ ÂÆåÊàê {total_operations} ‰∏™Êìç‰ΩúÔºåËÄóÊó∂ {duration:.3f}Áßí")
        
        # Ê≠•È™§4: È™åËØÅÁºìÂ≠òÁä∂ÊÄÅ
        for i in range(5):
            last_cmd = await cache_manager.get(f"user_user_{i}_last_cmd")
            assert last_cmd == f"python script{i}.py"
        
        print("   4Ô∏è‚É£ ÊâÄÊúâÁî®Êà∑Áä∂ÊÄÅÊ≠£Á°Æ‰øùÂ≠ò")
        
        # Ê≠•È™§5: È™åËØÅÂπ∂ÂèëÂÆâÂÖ®
        cache_stats = cache_manager.get_stats()
        assert cache_stats['hit_rate'] >= 0  # ÁºìÂ≠òÊ≠£Â∏∏Â∑•‰Ωú
        print("   5Ô∏è‚É£ Âπ∂ÂèëÊìç‰ΩúÂÆâÂÖ®ÂÆåÊàê")
        
        await event_bus.stop()
        print("   ‚úÖ Âπ∂ÂèëÁî®Êà∑Êìç‰ΩúÂ∑•‰ΩúÊµÅÂÆåÊàê")


# ===== Â∑•‰ΩúÊµÅ 6: ÂÆåÊï¥‰ºöËØùÁîüÂëΩÂë®Êúü =====
@pytest.mark.asyncio
async def test_complete_session_lifecycle():
    """ÊµãËØï‰ªé‰ºöËØùÂºÄÂßãÂà∞ÁªìÊùüÁöÑÂÆåÊï¥ÁîüÂëΩÂë®Êúü"""
    print("\nüìã Âú∫ÊôØ: ÂÆåÊï¥ÁöÑÁî®Êà∑‰ºöËØùÁîüÂëΩÂë®Êúü")
    
    from backend.services.event_bus import EventBus, Event
    from backend.models.base import EventType
    
    # ÂàùÂßãÂåñ‰∫ã‰ª∂ÊÄªÁ∫ø
    event_bus = EventBus()
    await event_bus.start()
    
    # ‰ºöËØù‰∫ã‰ª∂ËÆ∞ÂΩï
    session_events = []
    
    async def session_event_collector(event):
        session_events.append({
            'type': event.type,
            'timestamp': datetime.now(),
            'data': event.data
        })
    
    # ËÆ¢ÈòÖÊâÄÊúâÁõ∏ÂÖ≥‰∫ã‰ª∂
    event_types = [
        EventType.CLIENT_CONNECTED,
        EventType.TERMINAL_CONNECTED,
        EventType.COMMAND_EXECUTED,
        EventType.MEMORY_UPDATED,
        EventType.CLIENT_DISCONNECTED,
        EventType.TERMINAL_DISCONNECTED
    ]
    
    for event_type in event_types:
        event_bus.subscribe(event_type, session_event_collector)
    
    # ‰ºöËØùID
    session_id = f"session_{uuid.uuid4().hex[:8]}"
    
    # Ê≠•È™§1: Áî®Êà∑ËøûÊé•
    print(f"   1Ô∏è‚É£ Áî®Êà∑ËøûÊé• (‰ºöËØùID: {session_id})")
    await event_bus.publish(Event(
        type=EventType.CLIENT_CONNECTED,
        source="websocket_manager",
        data={"session_id": session_id, "client_id": "test_client"}
    ))
    
    # Ê≠•È™§2: ÁªàÁ´ØÂàùÂßãÂåñ
    print("   2Ô∏è‚É£ ÂàùÂßãÂåñÁªàÁ´ØËøûÊé•")
    await event_bus.publish(Event(
        type=EventType.TERMINAL_CONNECTED,
        source="terminal_bridge",
        data={"session_id": session_id}
    ))
    
    # Ê≠•È™§3: ÊâßË°å‰∏Ä‰∫õÂëΩ‰ª§
    print("   3Ô∏è‚É£ ÊâßË°åÁî®Êà∑ÂëΩ‰ª§")
    commands = ["pwd", "ls", "echo 'Hello World'"]
    for cmd in commands:
        await event_bus.publish(Event(
            type=EventType.COMMAND_EXECUTED,
            source="command_manager",
            data={
                "session_id": session_id,
                "command": cmd,
                "status": "success"
            }
        ))
        await asyncio.sleep(0.01)
    
    # Ê≠•È™§4: ‰øùÂ≠ò‰ºöËØùÂÜÖÂ≠ò
    print("   4Ô∏è‚É£ ‰øùÂ≠ò‰ºöËØùÈáçË¶ÅÂÜÖÂÆπ")
    await event_bus.publish(Event(
        type=EventType.MEMORY_UPDATED,
        source="memory_manager",
        data={
            "session_id": session_id,
            "memory_type": "session_summary",
            "content": "Áî®Êà∑ÊâßË°å‰∫ÜÊñá‰ª∂Á≥ªÁªüÊµèËßàÂíåÊµãËØïÂëΩ‰ª§"
        }
    ))
    
    # Ê≠•È™§5: ‰ºöËØùÁªìÊùü
    print("   5Ô∏è‚É£ Áî®Êà∑Êñ≠ÂºÄËøûÊé•")
    await event_bus.publish(Event(
        type=EventType.CLIENT_DISCONNECTED,
        source="websocket_manager",
        data={"session_id": session_id, "reason": "user_logout"}
    ))
    
    await event_bus.publish(Event(
        type=EventType.TERMINAL_DISCONNECTED,
        source="terminal_bridge",
        data={"session_id": session_id}
    ))
    
    # Á≠âÂæÖÊâÄÊúâ‰∫ã‰ª∂Â§ÑÁêÜ
    await asyncio.sleep(0.1)
    
    # Ê≠•È™§6: È™åËØÅÂÆåÊï¥ÁîüÂëΩÂë®Êúü
    assert len(session_events) >= 6
    
    # È™åËØÅ‰∫ã‰ª∂È°∫Â∫è
    event_sequence = [e['type'] for e in session_events]
    assert EventType.CLIENT_CONNECTED in event_sequence
    assert EventType.TERMINAL_CONNECTED in event_sequence
    assert EventType.COMMAND_EXECUTED in event_sequence
    assert EventType.CLIENT_DISCONNECTED in event_sequence
    
    print(f"   6Ô∏è‚É£ ËÆ∞ÂΩï‰∫Ü {len(session_events)} ‰∏™‰ºöËØù‰∫ã‰ª∂")
    print("   ‚úÖ ÂÆåÊï¥‰ºöËØùÁîüÂëΩÂë®ÊúüÂ∑•‰ΩúÊµÅÂÆåÊàê")
    
    await event_bus.stop()


# ===== ‰∏ªÊµãËØïËøêË°åÂô® =====
async def main():
    """ËøêË°åÊâÄÊúâÁ´ØÂà∞Á´ØÂ∑•‰ΩúÊµÅÊµãËØï"""
    print("üöÄ ËøêË°åÁ´ØÂà∞Á´ØÂ∑•‰ΩúÊµÅÊµãËØïÂ•ó‰ª∂")
    print("=" * 80)
    print("Ëøô‰∫õÊµãËØïÊ®°ÊãüÁúüÂÆûÁî®Êà∑Âú∫ÊôØÔºåÈ™åËØÅÁ≥ªÁªüÂêÑÁªÑ‰ª∂ÁöÑÂçèÂêåÂ∑•‰Ωú")
    print("=" * 80)
    
    workflows = [
        test_user_connection_command_workflow,
        test_context_monitoring_suggestion_workflow,
        test_memory_system_workflow,
        test_error_recovery_workflow,
        test_concurrent_users_workflow,
        test_complete_session_lifecycle
    ]
    
    passed = 0
    failed = 0
    
    for workflow in workflows:
        try:
            start_time = datetime.now()
            await workflow()
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            print(f"‚è±Ô∏è  ËÄóÊó∂: {duration:.3f}Áßí\n")
            passed += 1
        except Exception as e:
            failed += 1
            print(f"‚ùå Â∑•‰ΩúÊµÅÂ§±Ë¥•: {e}")
            import traceback
            traceback.print_exc()
            print()
    
    print("=" * 80)
    print(f"üìä ÊµãËØïÁªìÊûúÊ±áÊÄª")
    print(f"   ‚úÖ ÈÄöËøá: {passed}/{len(workflows)}")
    print(f"   ‚ùå Â§±Ë¥•: {failed}/{len(workflows)}")
    print(f"   üìà ÊàêÂäüÁéá: {(passed/len(workflows)*100):.1f}%")
    
    if passed == len(workflows):
        print("\nüéâ ÊâÄÊúâÁ´ØÂà∞Á´ØÂ∑•‰ΩúÊµÅÊµãËØïÈÄöËøáÔºÅ")
        print("‚ú® Á≥ªÁªüÂ∑≤È™åËØÅ‰ª•‰∏ãÂÖ≥ÈîÆËÉΩÂäõÔºö")
        print("   ‚Ä¢ Áî®Êà∑‰∫§‰∫íÂíåÂëΩ‰ª§ÊâßË°å")
        print("   ‚Ä¢ Êô∫ËÉΩÂª∫ËÆÆÂíå‰∏ä‰∏ãÊñáÁÆ°ÁêÜ")
        print("   ‚Ä¢ ÂÜÖÂ≠òÁ≥ªÁªüÂÆåÊï¥ÊµÅÁ®ã")
        print("   ‚Ä¢ ÈîôËØØÊÅ¢Â§çÂíåÂÆπÈîôÊú∫Âà∂")
        print("   ‚Ä¢ Âπ∂ÂèëÊìç‰ΩúÂíåÊÄßËÉΩ")
        print("   ‚Ä¢ ‰ºöËØùÁîüÂëΩÂë®ÊúüÁÆ°ÁêÜ")
    else:
        print("\n‚ö†Ô∏è  ÈÉ®ÂàÜÂ∑•‰ΩúÊµÅÊµãËØïÂ§±Ë¥•ÔºåÈúÄË¶ÅËøõ‰∏ÄÊ≠•Ë∞ÉËØï")
    
    return 0 if failed == 0 else 1


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))